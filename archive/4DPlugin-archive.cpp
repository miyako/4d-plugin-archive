/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-archive.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : archive
 #	author : miyako
 #	2021/04/29
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-archive.h"

Json::Value libarchiveStorage;
std::mutex libarchiveMutex;
std::map< std::string, std::future<void> >libarchiveTasks;

#pragma mark -

#ifdef WIN32

static int wcs_to_utf8(uastring& wstr, pathstring& str) {
    
    int error = 0;
    
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), NULL, 0, NULL, NULL);
    if(len){
        std::vector<char> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            str = pathstring((const char *)&buf[0]);
        }
    }else{
        str = pathstring((const char *)"");
        error = -1;
    }
    
    return error;
    
}

static int utf8_to_wcs(pathstring& str, uastring& wstr) {
    
    int error = 0;
    
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), NULL, 0);
    if(len){
        std::vector<char> buf((len + 1) * sizeof(wchar_t));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), (LPWSTR)&buf[0], len)){
            wstr = uastring((const wchar_t *)&buf[0]);
        }
    }else{
        wstr = uastring((const wchar_t *)L"");
        error = -1;
    }
    
    return error;
    
}

static void unescape_path(pathstring &path) {
    
    uastring wpath;
    utf8_to_wcs(path, wpath);
    unescape_path(wpath);
    wcs_to_utf8(wpath, path);
}

static void escape_path(pathstring &path) {
    
    uastring wpath;
    utf8_to_wcs(path, wpath);
    escape_path(wpath);
    wcs_to_utf8(wpath, path);
}

static void unescape_path(uastring &path) {
    
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '/')
            path.at(i) = L'\\';
}

static void escape_path(uastring &path) {
    
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '\\')
            path.at(i) = L'/';
}

#endif

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :

                break;
             
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                archive_abort_all();
                break;
                
			// --- archive
            
			case 1 :
				archive_read(params);
				break;
			case 2 :
				archive_write(params);
				break;
            case 3 :
                archive_version(params);
                break;
            case 4:
                archive_get_progress(params);
                break;
            case 5:
                archive_abort(params);
                break;
        }

	}
	catch(...)
	{

	}
}

static void generateUuid(std::string &uuid) {
    
#if VERSIONWIN
    RPC_WSTR str;
    UUID uid;
    if (UuidCreate(&uid) == RPC_S_OK) {
        if (UuidToString(&uid, &str) == RPC_S_OK) {
            size_t len = wcslen((const wchar_t *)str);
            std::vector<wchar_t>buf(len+1);
            memcpy(&buf[0], str, len * sizeof(wchar_t));
            _wcsupr((wchar_t *)&buf[0]);
            std::wstring wstr = std::wstring((const wchar_t *)&buf[0], len);
            wcs_to_utf8(wstr, uuid);
            RpcStringFree(&str);
        }
    }
#else
    NSString *u = [[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""];
    uuid = [u UTF8String];
#endif
}

static void archive_abort_all(void) {
        
    for( auto it = libarchiveTasks.begin(); it != libarchiveTasks.end() ; ++it ) {
        std::string uuid = it->first;
        Json::Value threadCtx = libarchiveStorage[uuid];
        if(threadCtx.isObject()) {
            std::lock_guard<std::mutex> lock(libarchiveMutex);
            libarchiveStorage[uuid]["abort"] = true;
        }
        it->second.get();
    }
    libarchiveTasks.clear();
}

static void archive_get_progress_and_abort(PA_PluginParameters params, bool abort = false) {
    
    PA_ObjectRef status  = PA_CreateObject();
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT p;
    p.fromParamAtIndex(pParams, 1);
    
    CUTF8String u8;
    p.copyUTF8String(&u8);
    std::string uuid = (const char *)u8.c_str();
    
    la_int64_t total_progress = 0;
    la_int64_t total_size = 0;
    
    bool complete = false;
    bool success = false;
    
    Json::Value threadCtx = libarchiveStorage[uuid];
    if(threadCtx.isObject()) {
        std::lock_guard<std::mutex> lock(libarchiveMutex);
        total_size = threadCtx["total"].asInt64();
        total_progress = threadCtx["progress"].asInt64();
        complete = threadCtx["complete"].asBool();
        success = threadCtx["success"].asBool();
    }
        
    if(abort) {
        std::map< std::string, std::future<void> >::iterator it = libarchiveTasks.find(uuid);
        if(it != libarchiveTasks.end()) {
            if(1) {
                std::lock_guard<std::mutex> lock(libarchiveMutex);
                libarchiveStorage[uuid]["abort"] = true;
            }
            it->second.get();
            libarchiveTasks.erase(it);
        }
        
    }
    
    ob_set_b(status, L"success", success);
    ob_set_b(status, L"complete", complete);
    ob_set_n(status, L"progress", total_progress);
    ob_set_n(status, L"total", total_size);
    
    PA_ReturnObject(params, status);
}

static void archive_get_progress(PA_PluginParameters params) {

    archive_get_progress_and_abort(params);
    
}

static void archive_abort(PA_PluginParameters params) {
  
    archive_get_progress_and_abort(params, true);

}

static void archive_write(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_CollectionRef src = PA_GetCollectionParameter(params, 1);
    
    C_TEXT dst;
    dst.fromParamAtIndex(pParams, 2);
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 3);
    PA_ObjectRef status  = PA_CreateObject();
    
    int flags = set_flags(options);
    
    bool skipHidden = false;
    bool keepParent = false;
    
    std::string ext;
    std::string compression;
    
    if(options) {
        
        //these flags can be explicitly SET

        if(ob_is_defined(options, L"skipHidden")) {
            skipHidden = ob_get_b(options, L"skipHidden");
        }
        
        if(ob_is_defined(options, L"keepParent")) {
            keepParent = ob_get_b(options, L"keepParent");
        }
        
        CUTF8String stringValue;
        
        if(ob_get_s(options, L"format", &stringValue)) {
            ext = (const char *)stringValue.c_str();
        }

        if(ob_get_s(options, L"compression", &stringValue)) {
            compression = (const char *)stringValue.c_str();
        }
        
    }
    
    pathstrings relative_paths;
    uastrings absolute_paths;
    
    get_subpaths_colletion(src,
                 &relative_paths,
                 &absolute_paths,
                 skipHidden,
                 keepParent);
    
    la_int64_t total_progress = 0;
    la_int64_t total_size     = 0;
    
    uastring dstPath;
    get_path(dst, dstPath);

    size_t count = relative_paths.size();
            
    for (size_t i = 0; i < count; ++i) {
        uastring absolute_path = absolute_paths.at(i);
        total_size += get_file_size(absolute_path);
    }
    
    std::string uuid;
    generateUuid(uuid);
    
    auto func = [](std::string uuid,
                   std::string ext,
                   std::string compression,
                   pathstrings relative_paths,
                   uastrings absolute_paths) {
        
        uastring dstPath;
        
        int flags = 0L;
        
        if(1) {
            
            std::lock_guard<std::mutex> lock(libarchiveMutex);
            Json::Value threadCtx = libarchiveStorage[uuid];

            if(threadCtx.isObject()) {
#if VERSIONWIN
                std::string dst = threadCtx["dst"].asString();
                utf8_to_wcs(dst, dstPath);
#else
                dstPath = threadCtx["dst"].asString();
#endif
                flags = threadCtx["flags"].asInt();
            }
        }
        
        //start
        
        la_int64_t total_progress = 0;
                        
        struct archive *a = archive_write_new();
        archive_write_disk_set_options(a, flags);
        archive_write_set_format_7zip(a);//default=7zip
        
        if(ext.length()) {
            archive_write_set_format_filter_by_ext(a, ext.c_str());
        }
        
        if(archive_format(a) == ARCHIVE_FORMAT_ZIP) {
            if(compression.length()) {
                if(compression == "store") {
                    archive_write_zip_set_compression_store(a);
                }
                if(compression == "deflate") {
                    archive_write_zip_set_compression_deflate(a);
                }
            }
        }
        
        int r = ARCHIVE_OK;
        
        r = open_archive_dst(r, a, dstPath);
        
        if(r == ARCHIVE_OK) {
         
            unsigned char buf[LIBARCHIVE_BUFFER_SIZE];
            struct archive_entry *f = archive_entry_new();
            
            bool processing = true;
            
            size_t count = relative_paths.size();
            
            auto startTime = std::chrono::high_resolution_clock::now();
            
            for (size_t i = 0; i < count; ++i) {
                
                pathstring relative_path = relative_paths.at(i);
                uastring absolute_path = absolute_paths.at(i);
                
                FILE *fd = open_path(r, a, f, relative_path, absolute_path);

                r = archive_write_header(a, f);
                
                if(fd) {

                    la_int64_t temp_progress = total_progress;
                    
                    if (r < ARCHIVE_OK) {
                        processing = check_warning(processing, r, a);
                        if(!processing) {

                            break;
                        }
                    }else{
                        size_t len = fread(buf, 1, LIBARCHIVE_BUFFER_SIZE, fd);
                        while ( len > 0 ) {
  
                            auto now = std::chrono::high_resolution_clock::now();
                            auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
                            
                            if(elapsedTime > 100)
                            {
                                startTime = now;
                             
                                std::lock_guard<std::mutex> lock(libarchiveMutex);
                                if(libarchiveStorage[uuid].isObject()) {
                                    libarchiveStorage[uuid]["progress"] = total_progress;
                                    if(libarchiveStorage[uuid]["abort"].asBool()) {
                                        i = count;
                                        break;
                                    }
                                }
                            }
                            
                            total_progress += len;
                            archive_write_data(a, buf, len);
                            len = fread(buf, 1, LIBARCHIVE_BUFFER_SIZE, fd);
                        }
                        
                    }
                    fclose(fd);
#if VERSIONMAC
                    set_file_xattr(f, absolute_path);
#endif
                    total_progress = temp_progress + get_file_size(absolute_path);
                }

                archive_entry_clear(f);
            }
            archive_entry_free(f);
        }
    
        archive_write_close(a);
        archive_write_free(a);
        
        //end
        
        if(1) {
            std::lock_guard<std::mutex> lock(libarchiveMutex);
            if(libarchiveStorage[uuid].isObject()) {
                libarchiveStorage[uuid]["complete"] = true;
                libarchiveStorage[uuid]["progress"] = total_progress;
                la_int64_t total_size = libarchiveStorage[uuid]["total"].asInt64();
                libarchiveStorage[uuid]["success"] = (total_progress == total_size);
            }
        }
    };

    Json::Value threadCtx(Json::objectValue);

#if VERSIONWIN
	std::string path;
	wcs_to_utf8(dstPath, path);
	threadCtx["dst"] = path;
#else
	threadCtx["dst"] = dstPath;
#endif
    threadCtx["total"] = total_size;
    threadCtx["progress"] = total_progress;
    threadCtx["complete"] = false;
    threadCtx["success"] = false;
    threadCtx["abort"] = false;
    threadCtx["flags"] = flags;
    
    if(options) {
        CUTF8String passphrase;
        if(ob_get_s(options, L"passphrase", &passphrase)) {
            threadCtx["passphrase"] = (const char *)passphrase.c_str();
        }
    }
    
    if(1) {
        std::lock_guard<std::mutex> lock(libarchiveMutex);
        libarchiveStorage[uuid] = threadCtx;
    }
    
    libarchiveTasks.insert(std::map< std::string, std::future<void> >::value_type(uuid ,
                                                                                  std::async(std::launch::async,
                                                                                             func,
                                                                                             uuid,
                                                                                             ext,
                                                                                             compression,
                                                                                             relative_paths,
                                                                                             absolute_paths)));
    
    ob_set_s(status, L"uuid", uuid.c_str());
    ob_set_b(status, L"complete", false);
    ob_set_b(status, L"success", false);
    ob_set_n(status, L"progress", total_progress);
    ob_set_n(status, L"total", total_size);
    
    PA_ReturnObject(params, status);
}


static void archive_read(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT src;
    src.fromParamAtIndex(pParams, 1);
    
    C_TEXT dst;
    dst.fromParamAtIndex(pParams, 2);
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 3);
    PA_ObjectRef status  = PA_CreateObject();
    
    int flags = set_flags(options);
    
    la_int64_t total_progress = 0;
    la_int64_t total_size = get_archive_file_size(options, src);

    uastring dstPath;
    get_folder_path(dst, dstPath);
    
    uastring srcPath;
    get_path(src, srcPath);
    
    std::string uuid;
    generateUuid(uuid);
    
    auto func = [](std::string uuid) {

        uastring dstPath;
        uastring srcPath;
        
        Json::Value passphrase;
        
        int flags = 0L;
        
        if(1) {
            
            std::lock_guard<std::mutex> lock(libarchiveMutex);
            Json::Value threadCtx = libarchiveStorage[uuid];

            if(threadCtx.isObject()) {
#if VERSIONWIN
                std::string dst = threadCtx["dst"].asString();
                std::string src = threadCtx["src"].asString();
                utf8_to_wcs(dst, dstPath);
                utf8_to_wcs(src, srcPath);
#else
                dstPath = threadCtx["dst"].asString();
                srcPath = threadCtx["src"].asString();
#endif
                passphrase = threadCtx["passphrase"];
                flags = threadCtx["flags"].asInt();
            }
        }
        
        //start
        
        la_int64_t total_progress = 0;
        
        struct archive *a = archive_read_new();
        archive_read_support_format_all(a);
        archive_read_support_filter_all(a);
        
        if(passphrase.isString()) {
            archive_read_add_passphrase(a, (const char *)passphrase.asString().c_str());
        }
        
        struct archive *e = archive_write_disk_new();
        archive_write_disk_set_options(e, flags);
        archive_write_disk_set_standard_lookup(e);
        
        int r = ARCHIVE_OK;
        
        struct archive_entry *f = NULL;
        
        r = open_archive_src(r, a, srcPath);
             
        if (ARCHIVE_OK == r) {

            bool processing = true;

            auto startTime = std::chrono::high_resolution_clock::now();
            
            while (processing) {
                
                r = archive_read_next_header(a, &f);
                
                processing = check_eof(processing, r, a);

                if(processing) {

                    set_pathname(f, dstPath);

                    r = archive_write_header(e, f);
                    
                    if (r < ARCHIVE_OK) {
                        processing = check_warning(processing, r, a);
                        if(!processing) {

                        }
                    }else{
                        
                        la_int64_t len = archive_entry_size(f);
                        
                        if (len > 0) {
                            
                            int r = ARCHIVE_OK;
                            const void *buf;
                            size_t size = 0L;
                            la_int64_t offset;

                            for (;;) {
                              
                                auto now = std::chrono::high_resolution_clock::now();
                                auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
                                
                                if(elapsedTime > 100)
                                {
                                    startTime = now;
                                 
                                    std::lock_guard<std::mutex> lock(libarchiveMutex);
                                    if(libarchiveStorage[uuid].isObject()) {
                                        libarchiveStorage[uuid]["progress"] = total_progress;
                                        if(libarchiveStorage[uuid]["abort"].asBool()) {
                                            processing = false;
                                        }
                                    }
                                }
                                
                              r = archive_read_data_block(a, &buf, &size, &offset);
                                
                                if (r == ARCHIVE_EOF) {
                                    r = ARCHIVE_OK;
                                    break;
                                }
                                
                                if (r < ARCHIVE_OK) {
                                    break;
                                }
                                
                                total_progress += size;
                                
                                r = (int)archive_write_data_block(e, buf, size, offset);
                                if (r < ARCHIVE_OK) {
                                    break;
                                }
  
                            }

                            processing = check_warning(processing, r, a);
                            
                            if(!processing) {

                            }else{
                                
                            }
                        }
                        r = archive_write_finish_entry(e);
                        processing = check_warning(processing, r, a);
                        if(!processing) {

                        }
                    }
                }
            }
            
        }
        
        //end
        
        if(1) {
            std::lock_guard<std::mutex> lock(libarchiveMutex);
            if(libarchiveStorage[uuid].isObject()) {
                libarchiveStorage[uuid]["complete"] = true;
                libarchiveStorage[uuid]["progress"] = total_progress;
                la_int64_t total_size = libarchiveStorage[uuid]["total"].asInt64();
                libarchiveStorage[uuid]["success"] = (total_progress == total_size);
            }
        }
    };

    Json::Value threadCtx(Json::objectValue);
#if VERSIONWIN
	std::string path;
	wcs_to_utf8(dstPath, path);
	threadCtx["dst"] = path;
	wcs_to_utf8(srcPath, path);
	threadCtx["src"] = path;
#else
	threadCtx["dst"] = dstPath;
	threadCtx["src"] = srcPath;
#endif
    threadCtx["total"] = total_size;
    threadCtx["progress"] = total_progress;
    threadCtx["complete"] = false;
    threadCtx["success"] = false;
    threadCtx["abort"] = false;
    threadCtx["flags"] = flags;
    
    if(options) {
        CUTF8String passphrase;
        if(ob_get_s(options, L"passphrase", &passphrase)) {
            threadCtx["passphrase"] = (const char *)passphrase.c_str();
        }
    }
    
    if(1) {
        std::lock_guard<std::mutex> lock(libarchiveMutex);
        libarchiveStorage[uuid] = threadCtx;
    }
    
    libarchiveTasks.insert(std::map< std::string, std::future<void> >::value_type(uuid,
                                                                                  std::async(std::launch::async, func, uuid)));
                                                                                  
    ob_set_s(status, L"uuid", uuid.c_str());
    ob_set_b(status, L"complete", false);
    ob_set_b(status, L"success", false);
    ob_set_n(status, L"progress", total_progress);
    ob_set_n(status, L"total", total_size);
    
    PA_ReturnObject(params, status);
}

#pragma mark -

static void collection_push(PA_CollectionRef c, const wchar_t *value) {
    
    if(c) {
        if(value) {
            CUTF16String u16 = CUTF16String((const PA_Unichar *)value);
            PA_Variable v = PA_CreateVariable(eVK_Unistring);
            PA_Unistring ustr = PA_CreateUnistring((PA_Unichar *)u16.c_str());
            PA_SetStringVariable(&v, &ustr);
            PA_SetCollectionElement(c, PA_GetCollectionLength(c), v);
            PA_ClearVariable(&v);
        }
    }
}

static void collection_push(PA_CollectionRef c, const char *value) {
    
    if(c) {
        if(value) {
            CUTF8String u8 = CUTF8String((const uint8_t *)value);
            CUTF16String u16;
    #ifdef _WIN32
            int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), NULL, 0);
            
            if(len){
                std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
                if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), (LPWSTR)&buf[0], len)){
                    u16 = CUTF16String((const PA_Unichar *)&buf[0]);
                }
            }else{
                u16 = CUTF16String((const PA_Unichar *)L"");
            }
    #else
            CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, u8.c_str(), u8.length(), kCFStringEncodingUTF8, true);
            if(str){
                CFIndex len = CFStringGetLength(str);
                std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
                CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
                u16 = CUTF16String((const PA_Unichar *)&buf[0]);
                CFRelease(str);
            }
    #endif
            PA_Variable v = PA_CreateVariable(eVK_Unistring);
            PA_Unistring ustr = PA_CreateUnistring((PA_Unichar *)u16.c_str());
            PA_SetStringVariable(&v, &ustr);
            PA_SetCollectionElement(c, PA_GetCollectionLength(c), v);
            PA_ClearVariable(&v);
        }
    }
}

#pragma mark -

static bool check_warning(bool processing, int r, struct archive *a) {
        
    if (r < ARCHIVE_OK) {
        switch (r) {
            case ARCHIVE_RETRY:
            case ARCHIVE_WARN:
                break;
            case ARCHIVE_FAILED:
            case ARCHIVE_FATAL:
                processing = false;
                break;
            default:
                break;
        }
    }
    
    return processing;
}

static bool check_warning(bool processing, int r, struct archive *a, PA_CollectionRef warnings) {
        
    if (r < ARCHIVE_OK) {
        switch (r) {
            case ARCHIVE_RETRY:
                break;
            case ARCHIVE_WARN:
#if DEBUG_RETURN_WARNINGS
                collection_push(warnings, archive_error_string(a));
#endif
                break;
            case ARCHIVE_FAILED:
            case ARCHIVE_FATAL:
                processing = false;
                break;
            default:
                break;
        }
    }
    
    return processing;
}

static bool check_eof(bool processing, int r, struct archive *a) {
        
    if (r == ARCHIVE_EOF) {
        processing = false;
    }
    
    if(processing) {
        processing = check_warning(processing, r, a);
    }
    
    return processing;
}

static bool check_eof(bool processing, int r, struct archive *a, PA_CollectionRef warnings, PA_ObjectRef status) {
        
    if (r == ARCHIVE_EOF) {
//        ob_set_b(status, L"success", true);
        processing = false;
    }
    
    if(processing) {
        processing = check_warning(processing, r, a, warnings);
    }
    
    if(!processing) {
#if DEBUG_RETURN_ERROR
        ob_set_s(status, L"error", archive_error_string(a));
#endif
    }

    return processing;
}
 
#pragma mark -

static int copy_data(struct archive *ar, struct archive *aw) {
    
  int r = ARCHIVE_OK;
  const void *buf;
  size_t size;
  la_int64_t offset;

  for (;;) {
    
    r = archive_read_data_block(ar, &buf, &size, &offset);
      
    if (r == ARCHIVE_EOF)
      return (ARCHIVE_OK);
      
    if (r < ARCHIVE_OK)
      return r;
      
    r = (int)archive_write_data_block(aw, buf, size, offset);
    if (r < ARCHIVE_OK) {
      return r;
    }
  }
}

static FILE *open_path(int r,
                       struct archive *a,
                       struct archive_entry *f,
                       pathstring& relative_path,
                       uastring& absolute_path) {
    
    /*
     
     libarchive api:
     
     archive_entry_set_pathname (file, folder, symlink)
     
     archive_entry_set_filetype(file, folder, symlink)
     archive_entry_set_perm(file, folder, symlink)
     
     archive_entry_set_symlink_type(symlink)
     archive_entry_set_symlink_utf8(symlink)
     
     archive_entry_set_size(file)
    
     */
    
    FILE *fd = NULL;
    
	archive_entry_set_pathname(f, relative_path.c_str());

#if VERSIONMAC
    fd = fopen  (absolute_path.c_str(),  "rb");
#else
    fd = _wfopen(absolute_path.c_str(), L"rb");
#endif
    
    bool isFile = set_file_info(f, absolute_path);
    
    if(fd) {
        if(isFile) {
            set_file_size(f, fd);
        }
        //symlink does not open
    }

    return fd;
}

#pragma mark -

static void get_path(C_TEXT& t, uastring& path) {
    
#if VERSIONMAC
    CUTF8String p;
    t.copyPath(&p);
    path = uastring((const char *)p.c_str());
#else
    CUTF16String p;
    t.copyUTF16String(&p);
    path = uastring((const wchar_t *)p.c_str());
#endif
}

static void get_folder_path(C_TEXT& t, uastring& path) {
    
    get_path(t, path);
    
    if(path.length() != 0) {
        
#if VERSIONMAC
    //remove last path separator
    if(path.at(path.size() - 1) == '/')
        path = path.substr(0, path.size() - 1);
    
    //append folder separator
    path += (const char *)"/";

#else
    //remove last path separator
    if(path.at(path.size() - 1) == L'\\')
        path = path.substr(0, path.size() - 1);
    
    //append folder separator
    path += (const wchar_t *)L"\\";
    
    //forward slash
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) ==L'\\')
            path.at(i) = L'/';
#endif
    }
    
}

static la_int64_t get_archive_file_size(PA_ObjectRef options, C_TEXT& t) {
    
    la_int64_t file_size = 0;
            
    uastring path;
    
    get_path(t, path);
    
    int r = ARCHIVE_OK;
    
    if(path.length() == 0) {
        r = ARCHIVE_FATAL;
    }else{
        
        struct archive *a = archive_read_new();
        archive_read_support_format_all(a);
        archive_read_support_filter_all(a);
        
        if(options) {
            CUTF8String passphrase;
            if(ob_get_s(options, L"passphrase", &passphrase)) {
                archive_read_add_passphrase(a, (const char *)passphrase.c_str());
            }
        }
        
#if VERSIONMAC
    r = archive_read_open_filename  (a, (const char *)   path.c_str(), LIBARCHIVE_BUFFER_SIZE);
#else
    r = archive_read_open_filename_w(a, (const wchar_t *)path.c_str(), LIBARCHIVE_BUFFER_SIZE);
#endif
        
        if(r == ARCHIVE_OK) {
            struct archive_entry *f = NULL;
            
            bool processing = true;
            
            while (processing) {
                
                int r = archive_read_next_header(a, &f);
                
                switch (r) {
                    case ARCHIVE_OK:
                        file_size += archive_entry_size(f);
                        break;
                    case ARCHIVE_RETRY:
                    case ARCHIVE_WARN:
                    case ARCHIVE_FAILED:
                    case ARCHIVE_FATAL:
                    case ARCHIVE_EOF:
                        processing = false;
                        break;
                }
                
            }
            archive_read_close(a);
        }
        archive_read_free(a);
    }
    
    return file_size;
}

static la_int64_t get_file_size(uastring& absolute_path) {
    
    la_int64_t file_size = 0;
 
#if VERSIONMAC
    struct stat stat1;
    if(0 == stat(absolute_path.c_str(), &stat1)) {
        file_size = stat1.st_size;//same as ftell
    }
#if VERSIONMAC
        ssize_t xattr = listxattr(absolute_path.c_str(), NULL, 0, XATTR_NOFOLLOW);
        if(xattr > 0) {
            file_size += xattr;
        }
#endif
#else
    
    HANDLE h = CreateFile(absolute_path.c_str(),
                          GENERIC_READ,
                          NULL, NULL,
                          OPEN_EXISTING,
                          NULL, NULL);
    if (h != INVALID_HANDLE_VALUE) {
        LARGE_INTEGER li;
        GetFileSizeEx(h, &li);
        CloseHandle(h);
        file_size = li.QuadPart;;
    }
#endif

    /*
     FILE *fd = NULL;
     
 #if VERSIONMAC
     fd = fopen  (absolute_path.c_str(),  "rb");
 #else
     fd = _wfopen(absolute_path.c_str(), L"rb");
 #endif
     
     if(fd) {
         fseek(fd, 0L, SEEK_END);
         long size = ftell(fd);
         fseek(fd, 0L, SEEK_SET);
         
         if(size == -1L) {

         }else{
             file_size += size;
         }
         
         fclose(fd);
     }
     */

    return file_size;
}

#pragma mark -

static int open_archive_src(int r, struct archive *a, uastring& path) {
        
    if(path.length() == 0) {
        r = ARCHIVE_FATAL;
    }else{
#if VERSIONMAC
    r = archive_read_open_filename  (a, (const char *)   path.c_str(), LIBARCHIVE_BUFFER_SIZE);
#else
    r = archive_read_open_filename_w(a, (const wchar_t *)path.c_str(), LIBARCHIVE_BUFFER_SIZE);
#endif
    }
        
    return r;
}

static int open_archive_src(int r, struct archive *a, C_TEXT& t, uastring& path) {
        
    get_path(t, path);
    
    r = open_archive_src(r, a, path);
            
    return r;
}

static int open_archive_dst(int r, struct archive *a, uastring& path) {
        
    if(path.length() == 0) {
        r = ARCHIVE_FATAL;
    }else{
#if VERSIONMAC
    r = archive_write_open_filename  (a, path.c_str());
#else
    r = archive_write_open_filename_w(a, path.c_str());
#endif
    }
    
    return r;
}

static int open_archive_dst(int r, struct archive *a, C_TEXT& t, uastring& path) {
    
    get_path(t, path);
    
    return open_archive_dst(r, a, path);
}

#pragma mark -

static void archive_version(PA_PluginParameters params) {
    
    PA_ObjectRef o = PA_CreateObject();
    
    ob_set_s(o, L"zstd", archive_libzstd_version());
    ob_set_s(o, L"bz", archive_bzlib_version());
    ob_set_s(o, L"lzma", archive_liblzma_version());
    ob_set_s(o, L"z", archive_zlib_version());
    ob_set_s(o, L"archive", archive_version_string());
    ob_set_s(o, L"lz4", archive_liblz4_version());
    
    ob_set_n(o, L"hardware_concurrency", std::thread::hardware_concurrency());
    
    PA_ReturnObject(params, o);
}

#pragma mark -

static int set_flags(PA_ObjectRef options) {
    
    int flags = 0L;
    
    flags |= ARCHIVE_EXTRACT_MAC_METADATA;//restore Mac extended metadata
    flags |= ARCHIVE_EXTRACT_OWNER;//try to set owner/group
    flags |= ARCHIVE_EXTRACT_TIME;//restore mtime/atime
    flags |= ARCHIVE_EXTRACT_PERM;//restore SUID/SGID/SVTX bits
    flags |= ARCHIVE_EXTRACT_ACL;//restore ACLs
    flags |= ARCHIVE_EXTRACT_FFLAGS;//restore fflags
    flags |= ARCHIVE_EXTRACT_XATTR;//restore xattrs
    flags |= ARCHIVE_EXTRACT_NO_OVERWRITE;//do not replace existing files
    flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;//do not overwrite files, even if one on disk is newer
    flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;//try to guard against extracts redirected by symlinks
    
    if(options) {
        
        //these flags can be explicitly SET
        
        if(ob_is_defined(options, L"noDotDot")) {
            if(ob_get_b(options, L"noDotDot")) {
                flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;//reject entries with '..' as path elements
            }
        }
        
        if(ob_is_defined(options, L"noAbsolutePaths")) {
            if(ob_get_b(options, L"noAbsolutePaths")) {
                flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;//reject entries with absolute paths
            }
        }

        if(ob_is_defined(options, L"noAutoDir")) {
            if(ob_get_b(options, L"noAutoDir")) {
                flags |= ARCHIVE_EXTRACT_NO_AUTODIR;//do not create parent directories as needed
            }
        }
        
        if(ob_is_defined(options, L"atomic")) {
            if(ob_get_b(options, L"atomic")) {
                flags |= ARCHIVE_EXTRACT_SAFE_WRITES;//extract atomically (using rename)
            }
        }
        
        if(ob_is_defined(options, L"noHFSCompression")) {
            if(ob_get_b(options, L"noHFSCompression")) {
                flags |= ARCHIVE_EXTRACT_NO_HFS_COMPRESSION;//do not use HFS+ compression if it was compressed
            }
        }
        
        if(ob_is_defined(options, L"forceHFSCompression")) {
            if(ob_get_b(options, L"forceHFSCompression")) {
                flags |= ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED;//use HFS+ compression if it was not compressed
            }
        }
                
        if(ob_is_defined(options, L"clearNoChangeFlags")) {
            if(ob_get_b(options, L"clearNoChangeFlags")) {
                flags |= ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS;//clear no-change flags when unlinking object
            }
        }
        
        if(ob_is_defined(options, L"unlink")) {
            if(ob_get_b(options, L"unlink")) {
                flags |= ARCHIVE_EXTRACT_UNLINK;//always unlink
            }
        }
        
        if(ob_is_defined(options, L"sparse")) {
            if(ob_get_b(options, L"sparse")) {
                flags |= ARCHIVE_EXTRACT_SPARSE;//detect blocks of 0 and write holes instead
            }
        }

        //these flags can be explicitly UNSET
        
        if(ob_is_defined(options, L"metadata")) {
            if(!ob_get_b(options, L"metadata")) {
                flags &= ~ARCHIVE_EXTRACT_MAC_METADATA;
            }
        }
        
        if(ob_is_defined(options, L"owner")) {
            if(!ob_get_b(options, L"owner")) {
                flags &= ~ARCHIVE_EXTRACT_OWNER;
            }
        }
        
        if(ob_is_defined(options, L"time")) {
            if(!ob_get_b(options, L"time")) {
                flags &= ~ARCHIVE_EXTRACT_TIME;
            }
        }
        
        if(ob_is_defined(options, L"perm")) {
            if(!ob_get_b(options, L"perm")) {
                flags &= ~ARCHIVE_EXTRACT_PERM;
            }
        }

        if(ob_is_defined(options, L"ACL")) {
            if(!ob_get_b(options, L"ACL")) {
                flags &= ~ARCHIVE_EXTRACT_ACL;
            }
        }
        
        if(ob_is_defined(options, L"fflags")) {
            if(!ob_get_b(options, L"fflags")) {
                flags &= ~ARCHIVE_EXTRACT_FFLAGS;
            }
        }
        
        if(ob_is_defined(options, L"xattr")) {
            if(!ob_get_b(options, L"xattr")) {
                flags &= ~ARCHIVE_EXTRACT_XATTR;
            }
        }
        
        if(ob_is_defined(options, L"noOverWrite")) {
            if(!ob_get_b(options, L"noOverWrite")) {
                flags &= ~ARCHIVE_EXTRACT_NO_OVERWRITE;
            }
        }
        
        if(ob_is_defined(options, L"noOverWriteNewer")) {
            if(!ob_get_b(options, L"noOverWriteNewer")) {
                flags &= ~ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
            }
        }
        
        if(ob_is_defined(options, L"secureSymlinks")) {
            if(!ob_get_b(options, L"secureSymlinks")) {
                flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;
            }
        }
                
    }
   
    return flags;
}

#pragma mark -

#if VERSIONMAC
static void get_subpaths(
                         uastring& spath,
                         pathstrings *relative_paths,
                         uastrings *absolute_paths,
                         bool skipHidden,
                         bool keepParent) {
    
    NSFileManager *fm = [[NSFileManager alloc]init];
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, spath.c_str());
    
    if(path) {
        
        BOOL isDirectory = YES;

        if([fm fileExistsAtPath:path isDirectory:&isDirectory]) {
            
            if(isDirectory) {
                
                NSString *folderName = [[path lastPathComponent]stringByAppendingString:@"/"];
                
                NSURL *baseUrl = [NSURL fileURLWithPath:path isDirectory:YES];
                NSString *basePath = [baseUrl path];
                if(![[basePath substringFromIndex:[basePath length]]isEqualToString:@"/"]) {
                    basePath = [basePath stringByAppendingString:@"/"];
                }
                
                NSArray *paths = (NSMutableArray *)[fm subpathsOfDirectoryAtPath:path error:NULL];
                
                if(keepParent) {
                    relative_paths->push_back([folderName UTF8String]);
                    absolute_paths->push_back([basePath UTF8String]);
                }
                
                //a folder with contents
                
                auto startTime = std::chrono::high_resolution_clock::now();
                
                for(NSUInteger i = 0; i < [paths count]; i++){
                    
                    auto now = std::chrono::high_resolution_clock::now();
                    auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
                    
                    if(elapsedTime > 100)
                    {
                        startTime = now;
                        PA_YieldAbsolute();
                    }
                    
                    NSString *itemPath = [paths objectAtIndex:i];
                    NSString *itemFullPath = [path stringByAppendingPathComponent:itemPath];
                    
                    //this method does not traverse a terminal symlink
                    NSDictionary *attributes = [fm attributesOfItemAtPath:itemFullPath error:nil];
                    if(attributes) {
                        bool is_hidden = false;
                        NSURL *u = [[NSURL alloc]initFileURLWithPath:itemFullPath];
                        if(u) {
                            NSNumber *isHidden;
                            if([u getResourceValue:&isHidden forKey:NSURLIsHiddenKey error:nil]) {
                                is_hidden = [isHidden boolValue];
                            }
                            [u release];
                        }
                        if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink]) {
                            
                        }else{
                            //this returns false for symbolic link
                            if([fm fileExistsAtPath:itemFullPath isDirectory:&isDirectory]){
                                if(isDirectory)
                                    itemPath = [itemPath stringByAppendingString:@"/"];
                            }
                        }
                        std::string absolute_path = [itemFullPath UTF8String];
                        std::string relative_path = [[folderName stringByAppendingString:itemPath]UTF8String];
                        
                        is_hidden |= (relative_path.at(0) == '.');/* invisible folder for mac */
                        is_hidden |= (relative_path.find("/.") != std::string::npos);/* invisible folder in path */
                        
                        if(!(skipHidden && is_hidden)) {
                            
                            absolute_paths->push_back(absolute_path);
                            
                            if(keepParent){
                                relative_paths->push_back(relative_path);
                            }else{
                                relative_paths->push_back([itemPath UTF8String]);
                            }
                        }
                    }
                }
                
            }else{
                //a file (over-ride ignore_dot, this is top level)
                relative_paths->push_back(std::string([[path lastPathComponent]UTF8String]));
                absolute_paths->push_back(spath);
            }
            
        }

        [path release];
    }
        
    [fm release];
}
#endif

#if VERSIONWIN
static void get_subpaths(
                         uastring& spath,
                         pathstrings *relative_paths,
                         uastrings *absolute_paths,
                         pathstring& folder_name,
                         bool skipHidden,
                         bool keepParent,
                         size_t absolutePathOffset) {
    
    WIN32_FIND_DATA find;
    
    HANDLE h = FindFirstFile(spath.c_str(), &find);
    
    uastring absolute_path;
    pathstring relative_path;
    
    if(h != INVALID_HANDLE_VALUE){
        
        auto startTime = std::chrono::high_resolution_clock::now();
        
        do {

            auto now = std::chrono::high_resolution_clock::now();
            auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(now - startTime).count();
            
            if(elapsedTime > 100)
            {
                startTime = now;
                PA_YieldAbsolute();
            }
            
            std::wstring sub_path = find.cFileName;
            
            /* ignore these meta */
            if((!wcscmp(sub_path.c_str(), L"..")) || (!wcscmp(sub_path.c_str(), L".")))
                continue;
            
            if((find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
            {
                /* is a folder */
                if(!absolutePathOffset)
                {
                    /* is top level */
                    /* use this length to convert absolute path to relative */
                    absolutePathOffset = spath.size() - 1;
                    
                    wcs_to_utf8(sub_path + L"/", folder_name);
                    
                    /* if flag specified, ignore (special option for top level) */
                    if(keepParent)
                    {
                        absolute_paths->push_back(spath);
                        relative_paths->push_back(folder_name);
                    }
                    
                    /* recursive call with wildcard */
                    get_subpaths(spath + L"\\*",
                                 relative_paths,
                                 absolute_paths,
                                 folder_name,
                                 skipHidden,
                                 keepParent,
                                 absolutePathOffset);
                    
                }else{
                    /* not top level */
                    /* trim the wildcard */
                    absolute_path = spath.substr(0, spath.size() - 1) + sub_path;
                    
                    uastring base_path = absolute_path.substr(absolutePathOffset + 2);
                    /* base_path += sub_path;*/
                    /* because this is a folder path */
                    base_path += L"\\";
                    escape_path(base_path);
                    wcs_to_utf8(base_path, relative_path);
                    relative_path = folder_name + relative_path;
                    
                    bool is_hidden = (GetFileAttributes(absolute_path.c_str()) & FILE_ATTRIBUTE_HIDDEN) == FILE_ATTRIBUTE_HIDDEN;
                    is_hidden |= (relative_path.at(0) == '.');/* invisible folder for mac */
                    is_hidden |= (relative_path.find("/.") != pathstring::npos);/* invisible folder in path */
                    
                    if(!(!skipHidden & is_hidden))
                    {
                        absolute_paths->push_back(absolute_path);
                        
                        if(keepParent)
                        {
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                        
                        get_subpaths(absolute_path /* + sub_path */ + L"\\*",
                                     relative_paths,
                                     absolute_paths,
                                     folder_name,
                                     skipHidden,
                                     keepParent,
                                     absolutePathOffset);
                        
                    }
                    
                }
                
            }else{
                /* is file */
                if(!absolutePathOffset)
                {
                    /* top level */
                    absolute_path = spath;// + sub_path;
                    
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);
                    
                    absolute_paths->push_back(absolute_path);
                    relative_paths->push_back(relative_path);
                    
                }else{
                    /* not top level */
                    uastring base_path = spath.substr(0, spath.size() - 1);
                    absolute_path = base_path + sub_path;
                    
                    sub_path = base_path.substr(absolutePathOffset + 2) + sub_path;
                    
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);
                    relative_path = folder_name + relative_path;
                    
                    bool is_hidden = (GetFileAttributes(absolute_path.c_str()) & FILE_ATTRIBUTE_HIDDEN) == FILE_ATTRIBUTE_HIDDEN;
                    is_hidden |= (relative_path.at(0) == '.');/* invisible folder for mac */
                    is_hidden |= (relative_path.find("/.") != pathstring::npos);/* invisible folder in path */
                    
                    if(!(!skipHidden & is_hidden))
                    {
                        absolute_paths->push_back(absolute_path);
                        
                        if(keepParent)
                        {
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                    }
                    
                }
                
            }
            
        } while (FindNextFile(h, &find));
        /*
         if(!absolute_paths->size() && absolutePathOffset){
         wstring base_path = path.substr(0, path.size() - 1);
         relative_paths->push_back(folder_name);
         absolute_paths->push_back(base_path);
         }
         */
        FindClose(h);
        
    }
}

static void get_subpaths(
                         uastring& spath,
                         pathstrings *relative_paths,
                         uastrings *absolute_paths,
                         bool skipHidden,
                         bool keepParent) {
 
    pathstring folder_name;
    
	size_t absolutePathOffset = 0;
    get_subpaths(spath,
                 relative_paths,
                 absolute_paths,
                 folder_name,
                 skipHidden,
                 keepParent, absolutePathOffset);
}
#endif

static void get_subpaths_colletion(PA_CollectionRef src,
                         pathstrings *relative_paths,
                         uastrings *absolute_paths,
                         bool skipHidden,
                         bool keepParent) {
    
    if(src) {
        
        for(PA_long32 i = 0; i < PA_GetCollectionLength(src); ++i) {
            
            PA_Variable v = PA_GetCollectionElement(src, i);
            if(PA_GetVariableKind(v) == eVK_Unistring) {
                PA_Unistring u = PA_GetStringVariable(v);
#if VERSIONMAC
                std::string path;
                CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)u.fString, u.fLength);
                if(str) {
                    
                    NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, str, kCFURLHFSPathStyle, false);
                    if(u){
                        NSString *_path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLPOSIXPathStyle);
                        [u release];
                        if(_path) {
                            path = [_path UTF8String];
                            [_path release];
                        }
                    }
                    CFRelease(str);
                }
#else
                std::wstring path;
                if((u.fLength) && (u.fString)) {
                    path = std::wstring((const wchar_t *)PA_GetUnistring(&u));

					if (path.at(path.size() - 1) == L'\\')
						path = path.substr(0, path.size() - 1);
                }
#endif
                get_subpaths(path,
                             relative_paths,
                             absolute_paths,
                             skipHidden,
                             keepParent);
            }
        }
    }
}

#pragma mark -

#if VERSIONMAC
static bool set_file_symlink(struct archive_entry *f, uastring& absolute_path) {
    
    bool isFile = true;
    
    archive_entry_set_filetype(f, AE_IFLNK);
    archive_entry_set_symlink_type(f, AE_SYMLINK_TYPE_UNDEFINED);
    
    NSFileManager *fm = [[NSFileManager alloc]init];
    
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    if(path) {
        
        //this is the full path
        NSString *symlinkPath = [path stringByResolvingSymlinksInPath];
        if(symlinkPath) {
            NSDictionary *symlinkAttributes = [fm attributesOfItemAtPath:symlinkPath error:nil];
            if(symlinkAttributes) {
                NSString *symlinkFileType = [symlinkAttributes valueForKey:NSFileType];
                if(symlinkFileType) {
                    if([symlinkFileType isEqualToString:NSFileTypeDirectory]) {
                        archive_entry_set_symlink_type(f, AE_SYMLINK_TYPE_DIRECTORY);
                        isFile = false;
                    }else {
                        archive_entry_set_symlink_type(f, AE_SYMLINK_TYPE_FILE);
                    }
                }
            }
            
            //this is the relative path
            symlinkPath = [fm destinationOfSymbolicLinkAtPath:path error:nil];
            archive_entry_set_symlink_utf8(f, [symlinkPath UTF8String]);
        }
        [path release];
    }
    
    [fm release];
    
    return isFile;
}
#endif

#if VERSIONMAC
static ssize_t set_file_xattr(struct archive_entry *f, uastring& absolute_path) {

    const char *path = (const char *)absolute_path.c_str();
    
    ssize_t xattr = listxattr(path, NULL, 0, XATTR_NOFOLLOW);

    if(xattr > 0) {
        
        std::vector<char> buf(xattr);
        xattr = listxattr(path, &buf[0], xattr, XATTR_NOFOLLOW);
        const char *key = &buf[0];
        ssize_t len = xattr;
        while (len > 0) {
         
            ssize_t vlen = getxattr(path, key, NULL, 0, 0, 0);
            if (vlen > 0) {
                std::vector<char> vbuf(vlen + 1);
                vlen = getxattr(path, key, &vbuf[0], vlen, 0, 0);
                if(vlen > 0) {
                    archive_entry_xattr_add_entry(f, key, &vbuf[0], vlen);
                }
            }
            ssize_t keylen = strlen(key) + 1;
            len -= keylen;
            key += keylen;
        }
    
        return xattr;
    }
    
    return 0;
}
#endif

static bool set_file_info(struct archive_entry *f, uastring& absolute_path) {
    
    bool isFile = true;
    
#if VERSIONMAC
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    if(path) {
                
        NSDictionary *attributes = [fileManager attributesOfItemAtPath:path error:nil];
        if(attributes) {
            
            short perm = [[attributes valueForKey:NSFilePosixPermissions]shortValue];
            archive_entry_set_perm(f, perm);

            NSString *fileType = [attributes valueForKey:NSFileType];
            if([fileType isEqualToString:NSFileTypeRegular]) {
                archive_entry_set_filetype(f, AE_IFREG);
            }
            else if([fileType isEqualToString:NSFileTypeSymbolicLink]) {
                isFile = set_file_symlink(f, absolute_path);
            }
            else if([fileType isEqualToString:NSFileTypeDirectory]) {
                archive_entry_set_filetype(f, AE_IFDIR);
                isFile = false;
            }
            else if([fileType isEqualToString:NSFileTypeCharacterSpecial]) {
                archive_entry_set_filetype(f, AE_IFCHR);
                isFile = false;
            }
            else if([fileType isEqualToString:NSFileTypeBlockSpecial]) {
                archive_entry_set_filetype(f, AE_IFBLK);
                isFile = false;
            }
            else if([fileType isEqualToString:NSFileTypeSocket]) {
                archive_entry_set_filetype(f, AE_IFSOCK);
                isFile = false;
            }else{
                archive_entry_set_filetype(f, AE_IFREG);
            }
        }else{
            archive_entry_set_filetype(f, AE_IFREG);
            archive_entry_set_perm(f, 644);
        }
        
        [path release];
    }else{
        archive_entry_set_filetype(f, AE_IFREG);
        archive_entry_set_perm(f, 644);
    }
#else
    DWORD attributes = GetFileAttributesW(absolute_path.c_str());
    if (attributes & FILE_ATTRIBUTE_DIRECTORY) {
        archive_entry_set_filetype(f, AE_IFDIR);
        isFile = false;
    }else{
        archive_entry_set_filetype(f, AE_IFREG);
    }
    archive_entry_set_perm(f, 644);
#endif

    return isFile;
}

static bool set_file_size(struct archive_entry *f, FILE *fd) {
    
    bool success = false;
    
    fseek(fd, 0L, SEEK_END);
    long size = ftell(fd);
    fseek(fd, 0L, SEEK_SET);
    
    if(size == -1L) {

    }else{
        archive_entry_set_size(f, size);
        success = true;
    }
    
    return success;
}

#pragma mark -

static void set_pathname(struct archive_entry *f, uastring& dstPath) {
  
#if VERSIONMAC
    const char    *filename = archive_entry_pathname_utf8(f);
#else
    const wchar_t *filename = archive_entry_pathname_w   (f);
#endif
        
#if VERSIONMAC
    uastring fullpath = dstPath + (const char *)   filename;
    archive_entry_set_pathname_utf8(f, fullpath.c_str());
#else
    uastring fullpath = dstPath + (const wchar_t *)filename;
    archive_entry_copy_pathname_w  (f, fullpath.c_str());
#endif
}

static void set_pathname(struct archive_entry *f, PA_CollectionRef paths,  uastring& dstPath) {
  
#if VERSIONMAC
    const char    *filename = archive_entry_pathname_utf8(f);
#else
    const wchar_t *filename = archive_entry_pathname_w   (f);
#endif
    
#if DEBUG_RETURN_PATHS
    collection_push(paths, filename);
#endif
    
#if VERSIONMAC
    uastring fullpath = dstPath + (const char *)   filename;
    archive_entry_set_pathname_utf8(f, fullpath.c_str());
#else
    uastring fullpath = dstPath + (const wchar_t *)filename;
    archive_entry_copy_pathname_w  (f, fullpath.c_str());
#endif
}
